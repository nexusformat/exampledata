 
import numpy as np
from nexusformat.nexus import *
 
# Note this example script was generated by nxdl_to_hdf5.py using the current 
# installed version of the NEXUS definitions ver[v2020.10] 
 
root = NXroot()

# Create the GROUPS 
root['/entry'] = NXentry()
root['/entry'].attrs['EX_required'] = 'true'
root['/entry/data'] = NXdata()
root['/entry/data'].attrs['EX_required'] = 'true'
root['/entry/sample'] = NXsample()
root['/entry/sample'].attrs['EX_required'] = 'true'
root['/entry/sample/transformations'] = NXtransformations()
root['/entry/sample/transformations'].attrs['EX_required'] = 'false'
root['/entry/instrument'] = NXinstrument()
root['/entry/instrument'].attrs['EX_required'] = 'true'
root['/entry/instrument/attenuator'] = NXattenuator()
root['/entry/instrument/attenuator'].attrs['EX_required'] = 'false'
root['/entry/instrument/NXdetector_group'] = NXdetector_group()
root['/entry/instrument/NXdetector_group'].attrs['EX_required'] = 'true'
root['/entry/instrument/detector'] = NXdetector()
root['/entry/instrument/detector'].attrs['EX_required'] = 'true'
root['/entry/instrument/detector/transformations'] = NXtransformations()
root['/entry/instrument/detector/transformations'].attrs['EX_required'] = 'false'
root['/entry/instrument/detector/collection'] = NXcollection()
root['/entry/instrument/detector/collection'].attrs['EX_required'] = 'false'
root['/entry/instrument/detector/NXdetector_module'] = NXdetector_module()
root['/entry/instrument/detector/NXdetector_module'].attrs['EX_required'] = 'true'
root['/entry/instrument/beam'] = NXbeam()
root['/entry/instrument/beam'].attrs['EX_required'] = 'true'
root['/entry/instrument/beam/incident_wavelength_spectrum'] = NXdata()
root['/entry/instrument/beam/incident_wavelength_spectrum'].attrs['EX_required'] = 'false'
root['/entry/source'] = NXsource()
root['/entry/source'].attrs['EX_required'] = 'true'

# Create the FIELDS 
 
root['/entry/title'] = NXfield('SAMPLE-CHAR-DATA')
root['/entry/title'].attrs['type'] = 'NX_CHAR'
root['/entry/title'].attrs['EX_required'] = 'false'
 
root['/entry/start_time'] = NXfield('2021-03-29T15:51:40.027458')
root['/entry/start_time'].attrs['type'] = 'NX_DATE_TIME'
root['/entry/start_time'].attrs['EX_required'] = 'true'
 
root['/entry/end_time'] = NXfield('2021-03-29T15:51:40.030457')
root['/entry/end_time'].attrs['type'] = 'NX_DATE_TIME'
root['/entry/end_time'].attrs['EX_required'] = 'false'
 
root['/entry/end_time_estimated'] = NXfield('2021-03-29T15:51:40.039474')
root['/entry/end_time_estimated'].attrs['type'] = 'NX_DATE_TIME'
root['/entry/end_time_estimated'].attrs['EX_required'] = 'true'
 
# Valid enumeration values for root['/entry']['definition'] are: 
#	 NXmx
 
root['/entry/definition'] = NXfield('NXmx')
root['/entry/definition'].attrs['type'] = 'NX_CHAR'
root['/entry/definition'].attrs['EX_required'] = 'true'
 
root['/entry/data/data'] = NXfield(1.0)
root['/entry/data/data'].attrs['type'] = 'NX_NUMBER'
root['/entry/data/data'].attrs['EX_required'] = 'true'
 
root['/entry/sample/name'] = NXfield('SAMPLE-CHAR-DATA')
root['/entry/sample/name'].attrs['type'] = 'NX_CHAR'
root['/entry/sample/name'].attrs['EX_required'] = 'true'
 
root['/entry/sample/depends_on'] = NXfield('SAMPLE-CHAR-DATA')
root['/entry/sample/depends_on'].attrs['type'] = 'NX_CHAR'
root['/entry/sample/depends_on'].attrs['EX_required'] = 'true'
 
root['/entry/sample/temperature'] = NXfield(1.0)
root['/entry/sample/temperature'].attrs['type'] = 'NX_NUMBER'
root['/entry/sample/temperature'].attrs['EX_required'] = 'false'
root['/entry/sample/temperature'].attrs['units'] = 'NX_TEMPERATURE'
 
root['/entry/instrument/name'] = NXfield('SAMPLE-CHAR-DATA')
root['/entry/instrument/name'].attrs['type'] = 'NX_CHAR'
root['/entry/instrument/name'].attrs['EX_required'] = 'true'
 
root['/entry/instrument/time_zone'] = NXfield('2021-03-29T15:51:40.065477')
root['/entry/instrument/time_zone'].attrs['type'] = 'NX_DATE_TIME'
root['/entry/instrument/time_zone'].attrs['EX_required'] = 'true'
 
root['/entry/instrument/attenuator/attenuator_transmission'] = NXfield(1.0)
root['/entry/instrument/attenuator/attenuator_transmission'].attrs['type'] = 'NX_NUMBER'
root['/entry/instrument/attenuator/attenuator_transmission'].attrs['EX_required'] = 'false'
root['/entry/instrument/attenuator/attenuator_transmission'].attrs['units'] = 'NX_UNITLESS'
 
root['/entry/instrument/NXdetector_group/group_names'] = NXfield('SAMPLE-CHAR-DATA')
root['/entry/instrument/NXdetector_group/group_names'].attrs['type'] = 'NX_CHAR'
root['/entry/instrument/NXdetector_group/group_names'].attrs['EX_required'] = 'true'
 
root['/entry/instrument/NXdetector_group/group_index'] = NXfield(1)
root['/entry/instrument/NXdetector_group/group_index'].attrs['type'] = 'NX_INT'
root['/entry/instrument/NXdetector_group/group_index'].attrs['EX_required'] = 'true'
 
root['/entry/instrument/NXdetector_group/group_parent'] = NXfield(1)
root['/entry/instrument/NXdetector_group/group_parent'].attrs['type'] = 'NX_INT'
root['/entry/instrument/NXdetector_group/group_parent'].attrs['EX_required'] = 'true'
 
root['/entry/instrument/detector/depends_on'] = NXfield('SAMPLE-CHAR-DATA')
root['/entry/instrument/detector/depends_on'].attrs['type'] = 'NX_CHAR'
root['/entry/instrument/detector/depends_on'].attrs['EX_required'] = 'false'
 
root['/entry/instrument/detector/data'] = NXfield(1.0)
root['/entry/instrument/detector/data'].attrs['type'] = 'NX_NUMBER'
root['/entry/instrument/detector/data'].attrs['EX_required'] = 'true'
 
root['/entry/instrument/detector/description'] = NXfield('SAMPLE-CHAR-DATA')
root['/entry/instrument/detector/description'].attrs['type'] = 'NX_CHAR'
root['/entry/instrument/detector/description'].attrs['EX_required'] = 'true'
 
root['/entry/instrument/detector/time_per_channel'] = NXfield('SAMPLE-CHAR-DATA')
root['/entry/instrument/detector/time_per_channel'].attrs['type'] = 'NX_CHAR'
root['/entry/instrument/detector/time_per_channel'].attrs['units'] = 'NX_TIME'
root['/entry/instrument/detector/time_per_channel'].attrs['EX_required'] = 'false'
 
root['/entry/instrument/detector/NXdetector_module/data_origin'] = NXfield(1)
root['/entry/instrument/detector/NXdetector_module/data_origin'].attrs['type'] = 'NX_INT'
root['/entry/instrument/detector/NXdetector_module/data_origin'].attrs['EX_required'] = 'true'
 
root['/entry/instrument/detector/NXdetector_module/data_size'] = NXfield(1)
root['/entry/instrument/detector/NXdetector_module/data_size'].attrs['type'] = 'NX_INT'
root['/entry/instrument/detector/NXdetector_module/data_size'].attrs['EX_required'] = 'true'
 
root['/entry/instrument/detector/NXdetector_module/data_stride'] = NXfield(1)
root['/entry/instrument/detector/NXdetector_module/data_stride'].attrs['type'] = 'NX_INT'
root['/entry/instrument/detector/NXdetector_module/data_stride'].attrs['EX_required'] = 'false'
 
root['/entry/instrument/detector/NXdetector_module/module_offset'] = NXfield(1.0)
root['/entry/instrument/detector/NXdetector_module/module_offset'].attrs['type'] = 'NX_NUMBER'
root['/entry/instrument/detector/NXdetector_module/module_offset'].attrs['EX_required'] = 'false'
root['/entry/instrument/detector/NXdetector_module/module_offset'].attrs['units'] = 'NX_LENGTH'
 
root['/entry/instrument/detector/NXdetector_module/fast_pixel_direction'] = NXfield(1.0)
root['/entry/instrument/detector/NXdetector_module/fast_pixel_direction'].attrs['type'] = 'NX_NUMBER'
root['/entry/instrument/detector/NXdetector_module/fast_pixel_direction'].attrs['EX_required'] = 'true'
root['/entry/instrument/detector/NXdetector_module/fast_pixel_direction'].attrs['units'] = 'NX_LENGTH'
 
root['/entry/instrument/detector/NXdetector_module/slow_pixel_direction'] = NXfield(1.0)
root['/entry/instrument/detector/NXdetector_module/slow_pixel_direction'].attrs['type'] = 'NX_NUMBER'
root['/entry/instrument/detector/NXdetector_module/slow_pixel_direction'].attrs['EX_required'] = 'true'
root['/entry/instrument/detector/NXdetector_module/slow_pixel_direction'].attrs['units'] = 'NX_LENGTH'
 
root['/entry/instrument/detector/distance'] = NXfield(1.0)
root['/entry/instrument/detector/distance'].attrs['type'] = 'NX_FLOAT'
root['/entry/instrument/detector/distance'].attrs['EX_required'] = 'true'
root['/entry/instrument/detector/distance'].attrs['units'] = 'NX_LENGTH'
 
root['/entry/instrument/detector/distance_derived'] = NXfield(np.int8(0))
root['/entry/instrument/detector/distance_derived'].attrs['type'] = 'NX_BOOLEAN'
root['/entry/instrument/detector/distance_derived'].attrs['EX_required'] = 'true'
 
root['/entry/instrument/detector/dead_time'] = NXfield(1.0)
root['/entry/instrument/detector/dead_time'].attrs['type'] = 'NX_FLOAT'
root['/entry/instrument/detector/dead_time'].attrs['EX_required'] = 'false'
root['/entry/instrument/detector/dead_time'].attrs['units'] = 'NX_TIME'
 
root['/entry/instrument/detector/count_time'] = NXfield(1.0)
root['/entry/instrument/detector/count_time'].attrs['type'] = 'NX_NUMBER'
root['/entry/instrument/detector/count_time'].attrs['EX_required'] = 'true'
root['/entry/instrument/detector/count_time'].attrs['units'] = 'NX_TIME'
 
root['/entry/instrument/detector/beam_center_derived'] = NXfield(np.int8(0))
root['/entry/instrument/detector/beam_center_derived'].attrs['type'] = 'NX_BOOLEAN'
root['/entry/instrument/detector/beam_center_derived'].attrs['EX_required'] = 'true'
 
root['/entry/instrument/detector/beam_center_x'] = NXfield(1.0)
root['/entry/instrument/detector/beam_center_x'].attrs['type'] = 'NX_FLOAT'
root['/entry/instrument/detector/beam_center_x'].attrs['EX_required'] = 'true'
root['/entry/instrument/detector/beam_center_x'].attrs['units'] = 'NX_LENGTH'
 
root['/entry/instrument/detector/beam_center_y'] = NXfield(1.0)
root['/entry/instrument/detector/beam_center_y'].attrs['type'] = 'NX_FLOAT'
root['/entry/instrument/detector/beam_center_y'].attrs['EX_required'] = 'true'
root['/entry/instrument/detector/beam_center_y'].attrs['units'] = 'NX_LENGTH'
 
root['/entry/instrument/detector/angular_calibration_applied'] = NXfield(np.int8(0))
root['/entry/instrument/detector/angular_calibration_applied'].attrs['type'] = 'NX_BOOLEAN'
root['/entry/instrument/detector/angular_calibration_applied'].attrs['EX_required'] = 'false'
 
root['/entry/instrument/detector/angular_calibration'] = NXfield(1.0)
root['/entry/instrument/detector/angular_calibration'].attrs['type'] = 'NX_FLOAT'
root['/entry/instrument/detector/angular_calibration'].attrs['EX_required'] = 'false'
 
root['/entry/instrument/detector/flatfield_applied'] = NXfield(np.int8(0))
root['/entry/instrument/detector/flatfield_applied'].attrs['type'] = 'NX_BOOLEAN'
root['/entry/instrument/detector/flatfield_applied'].attrs['EX_required'] = 'false'
 
root['/entry/instrument/detector/flatfield'] = NXfield(1.0)
root['/entry/instrument/detector/flatfield'].attrs['type'] = 'NX_NUMBER'
root['/entry/instrument/detector/flatfield'].attrs['EX_required'] = 'false'
 
root['/entry/instrument/detector/flatfield_error'] = NXfield(1.0)
root['/entry/instrument/detector/flatfield_error'].attrs['type'] = 'NX_NUMBER'
root['/entry/instrument/detector/flatfield_error'].attrs['EX_required'] = 'false'
 
root['/entry/instrument/detector/flatfield_errors'] = NXfield(1.0)
root['/entry/instrument/detector/flatfield_errors'].attrs['type'] = 'NX_NUMBER'
root['/entry/instrument/detector/flatfield_errors'].attrs['EX_required'] = 'false'
 
root['/entry/instrument/detector/pixel_mask_applied'] = NXfield(np.int8(0))
root['/entry/instrument/detector/pixel_mask_applied'].attrs['type'] = 'NX_BOOLEAN'
root['/entry/instrument/detector/pixel_mask_applied'].attrs['EX_required'] = 'false'
 
root['/entry/instrument/detector/pixel_mask'] = NXfield(1)
root['/entry/instrument/detector/pixel_mask'].attrs['type'] = 'NX_INT'
root['/entry/instrument/detector/pixel_mask'].attrs['EX_required'] = 'true'
 
root['/entry/instrument/detector/countrate_correction_applied'] = NXfield(np.int8(0))
root['/entry/instrument/detector/countrate_correction_applied'].attrs['type'] = 'NX_BOOLEAN'
root['/entry/instrument/detector/countrate_correction_applied'].attrs['EX_required'] = 'false'
 
root['/entry/instrument/detector/bit_depth_readout'] = NXfield(1)
root['/entry/instrument/detector/bit_depth_readout'].attrs['type'] = 'NX_INT'
root['/entry/instrument/detector/bit_depth_readout'].attrs['EX_required'] = 'true'
 
root['/entry/instrument/detector/detector_readout_time'] = NXfield(1.0)
root['/entry/instrument/detector/detector_readout_time'].attrs['type'] = 'NX_FLOAT'
root['/entry/instrument/detector/detector_readout_time'].attrs['EX_required'] = 'false'
root['/entry/instrument/detector/detector_readout_time'].attrs['units'] = 'NX_TIME'
 
root['/entry/instrument/detector/frame_time'] = NXfield(1.0)
root['/entry/instrument/detector/frame_time'].attrs['type'] = 'NX_FLOAT'
root['/entry/instrument/detector/frame_time'].attrs['EX_required'] = 'false'
root['/entry/instrument/detector/frame_time'].attrs['units'] = 'NX_TIME'
 
root['/entry/instrument/detector/gain_setting'] = NXfield('SAMPLE-CHAR-DATA')
root['/entry/instrument/detector/gain_setting'].attrs['type'] = 'NX_CHAR'
root['/entry/instrument/detector/gain_setting'].attrs['EX_required'] = 'false'
 
root['/entry/instrument/detector/saturation_value'] = NXfield(1)
root['/entry/instrument/detector/saturation_value'].attrs['type'] = 'NX_INT'
root['/entry/instrument/detector/saturation_value'].attrs['EX_required'] = 'false'
 
root['/entry/instrument/detector/underload_value'] = NXfield(1)
root['/entry/instrument/detector/underload_value'].attrs['type'] = 'NX_INT'
root['/entry/instrument/detector/underload_value'].attrs['EX_required'] = 'false'
 
root['/entry/instrument/detector/sensor_material'] = NXfield('SAMPLE-CHAR-DATA')
root['/entry/instrument/detector/sensor_material'].attrs['type'] = 'NX_CHAR'
root['/entry/instrument/detector/sensor_material'].attrs['EX_required'] = 'true'
 
root['/entry/instrument/detector/sensor_thickness'] = NXfield(1.0)
root['/entry/instrument/detector/sensor_thickness'].attrs['type'] = 'NX_FLOAT'
root['/entry/instrument/detector/sensor_thickness'].attrs['EX_required'] = 'true'
root['/entry/instrument/detector/sensor_thickness'].attrs['units'] = 'NX_LENGTH'
 
root['/entry/instrument/detector/threshold_energy'] = NXfield(1.0)
root['/entry/instrument/detector/threshold_energy'].attrs['type'] = 'NX_FLOAT'
root['/entry/instrument/detector/threshold_energy'].attrs['EX_required'] = 'false'
root['/entry/instrument/detector/threshold_energy'].attrs['units'] = 'NX_ENERGY'
 
root['/entry/instrument/detector/type'] = NXfield('SAMPLE-CHAR-DATA')
root['/entry/instrument/detector/type'].attrs['type'] = 'NX_CHAR'
root['/entry/instrument/detector/type'].attrs['EX_required'] = 'false'
 
root['/entry/instrument/beam/incident_wavelength'] = NXfield(1.0)
root['/entry/instrument/beam/incident_wavelength'].attrs['type'] = 'NX_FLOAT'
root['/entry/instrument/beam/incident_wavelength'].attrs['EX_required'] = 'true'
root['/entry/instrument/beam/incident_wavelength'].attrs['units'] = 'NX_WAVELENGTH'
 
root['/entry/instrument/beam/incident_wavelength_weight'] = NXfield(1.0)
root['/entry/instrument/beam/incident_wavelength_weight'].attrs['type'] = 'NX_FLOAT'
root['/entry/instrument/beam/incident_wavelength_weight'].attrs['EX_required'] = 'false'
 
root['/entry/instrument/beam/incident_wavelength_weights'] = NXfield(1.0)
root['/entry/instrument/beam/incident_wavelength_weights'].attrs['type'] = 'NX_FLOAT'
root['/entry/instrument/beam/incident_wavelength_weights'].attrs['EX_required'] = 'false'
 
root['/entry/instrument/beam/incident_wavelength_spread'] = NXfield(1.0)
root['/entry/instrument/beam/incident_wavelength_spread'].attrs['type'] = 'NX_FLOAT'
root['/entry/instrument/beam/incident_wavelength_spread'].attrs['EX_required'] = 'false'
root['/entry/instrument/beam/incident_wavelength_spread'].attrs['units'] = 'NX_WAVELENGTH'
 
root['/entry/instrument/beam/flux'] = NXfield(1.0)
root['/entry/instrument/beam/flux'].attrs['type'] = 'NX_FLOAT'
root['/entry/instrument/beam/flux'].attrs['EX_required'] = 'false'
root['/entry/instrument/beam/flux'].attrs['units'] = 'NX_FLUX'
 
root['/entry/instrument/beam/total_flux'] = NXfield(1.0)
root['/entry/instrument/beam/total_flux'].attrs['type'] = 'NX_FLOAT'
root['/entry/instrument/beam/total_flux'].attrs['EX_required'] = 'true'
root['/entry/instrument/beam/total_flux'].attrs['units'] = 'NX_FREQUENCY'
 
root['/entry/instrument/beam/incident_beam_size'] = NXfield(1.0)
root['/entry/instrument/beam/incident_beam_size'].attrs['type'] = 'NX_FLOAT'
root['/entry/instrument/beam/incident_beam_size'].attrs['EX_required'] = 'true'
root['/entry/instrument/beam/incident_beam_size'].attrs['units'] = 'NX_LENGTH'
 
# Valid enumeration values for root['/entry/instrument/beam']['profile'] are: 
#	 Gaussian
#	 Airy
#	 top-hat
#	 rectangular
 
root['/entry/instrument/beam/profile'] = NXfield('Gaussian')
root['/entry/instrument/beam/profile'].attrs['type'] = 'NX_CHAR'
root['/entry/instrument/beam/profile'].attrs['EX_required'] = 'true'
 
root['/entry/instrument/beam/incident_polarisation_stokes'] = NXfield('SAMPLE-CHAR-DATA')
root['/entry/instrument/beam/incident_polarisation_stokes'].attrs['type'] = 'NX_CHAR'
root['/entry/instrument/beam/incident_polarisation_stokes'].attrs['EX_required'] = 'true'
 
root['/entry/source/name'] = NXfield('SAMPLE-CHAR-DATA')
root['/entry/source/name'].attrs['type'] = 'NX_CHAR'
root['/entry/source/name'].attrs['EX_required'] = 'true'

# Create the DOC strings 
root['/entry'].attrs['EX_doc'] = 'Note, it is recommended that ``file_name`` and ``file_time`` are included     as attributes at the root of a file that includes :ref:`NXmx`. See     :ref:`NXroot`. '
root['/entry/start_time'].attrs['EX_doc'] = 'ISO 8601 time/date of the first data point collected in UTC,      using the Z suffix to avoid confusion with local time.      Note that the time zone of the beamline should be provided in      NXentry/NXinstrument/time_zone. '
root['/entry/end_time'].attrs['EX_doc'] = 'ISO 8601 time/date of the last data point collected in UTC,      using the Z suffix to avoid confusion with local time.      Note that the time zone of the beamline should be provided in      NXentry/NXinstrument/time_zone. This field should only be      filled when the value is accurately observed. If the data      collection aborts or otherwise prevents accurate recording of      the end_time, this field should be omitted. '
root['/entry/end_time_estimated'].attrs['EX_doc'] = 'ISO 8601 time/date of the last data point collected in UTC,      using the Z suffix to avoid confusion with local time.      Note that the time zone of the beamline should be provided in      NXentry/NXinstrument/time_zone. This field may be filled      with a value estimated before an observed value is available. '
root['/entry/definition'].attrs['EX_doc'] = 'NeXus NXDL schema to which this file conforms '
root['/entry/data/data'].attrs['EX_doc'] = 'For a dimension-2 detector, the rank of the data array will be 3.       For a dimension-3 detector, the rank of the data array will be 4.       This allows for the introduction of the frame number as the       first index. '
root['/entry/sample/name'].attrs['EX_doc'] = 'Descriptive name of sample '
root['/entry/sample/depends_on'].attrs['EX_doc'] = 'This is a requirement to describe for any scan experiment.       The axis on which the sample position depends may be stored       anywhere, but is normally stored in the NXtransformations       group within the NXsample group.       If there is no goniometer, e.g. with a jet, depends_on       should be set to "." '
root['/entry/sample/transformations'].attrs['EX_doc'] = 'This is the recommended location for sample goniometer       and other related axes.       This is a requirement to describe for any scan experiment.       The reason it is optional is mainly to accommodate XFEL       single shot exposures.       Use of the depends_on field and the NXtransformations group is       strongly recommended. As noted above this should be an absolute       requirement to have for any scan experiment.       The reason it is optional is mainly to accommodate XFEL       single shot exposures. '
root['/entry/instrument/name'].attrs['EX_doc'] = 'Name of instrument. Consistency with the controlled       vocabulary beamline naming in       https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_diffrn_source.pdbx_synchrotron_beamline.html       and       https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_diffrn_source.type.html       is highly recommended. '
root['/entry/instrument/time_zone'].attrs['EX_doc'] = 'ISO 8601 time_zone offset from UTC. '
root['/entry/instrument/NXdetector_group'].attrs['EX_doc'] = 'Optional logical grouping of detectors.       Each detector is represented as an NXdetector       with its own detector data array. Each detector data array       may be further decomposed into array sections by use of       NXdetector_module groups. Detectors can be grouped logically       together using NXdetector_group. Groups can be further grouped       hierarchically in a single NXdetector_group (for example, if       there are multiple detectors at an endstation or multiple       endstations at a facility). Alternatively, multiple       NXdetector_groups can be provided.       The groups are defined hierarchically, with names given       in the group_names field, unique identifying indices given       in the field group_index, and the level in the hierarchy       given in the group_parent field. For example if an x-ray       detector group, DET, consists of four detectors in a       rectangular array::          DTL DTR          DLL DLR       We could have::        group_names: ["DET", "DTL", "DTR", "DLL", "DLR"]         group_index: [1, 2, 3, 4, 5]         group_parent: [-1, 1, 1, 1, 1] '
root['/entry/instrument/NXdetector_group/group_names'].attrs['EX_doc'] = 'An array of the names of the detectors or the names of        hierarchical groupings of detectors. '
root['/entry/instrument/NXdetector_group/group_index'].attrs['EX_doc'] = 'An array of unique identifiers for detectors or groupings        of detectors.        Each ID is a unique ID for the corresponding detector or group        named in the field group_names. The IDs are positive integers        starting with 1. '
root['/entry/instrument/NXdetector_group/group_parent'].attrs['EX_doc'] = 'An array of the hierarchical levels of the parents of detectors        or groupings of detectors.        A top-level grouping has parent level -1. '
root['/entry/instrument/detector'].attrs['EX_doc'] = 'Normally the detector group will have the name ``detector``.       However, in the case of multiple detectors, each detector       needs a uniquely named NXdetector. '
root['/entry/instrument/detector/depends_on'].attrs['EX_doc'] = 'NeXus path to the detector positioner axis that most directly        supports the detector. In the case of a single-module        detector, the detector axis chain may start here. '
root['/entry/instrument/detector/transformations'].attrs['EX_doc'] = 'Location for axes (transformations) to do with the        detector. In the case of a single-module detector, the        axes of the detector axis chain may be stored here. '
root['/entry/instrument/detector/collection'].attrs['EX_doc'] = 'Suggested container for detailed non-standard detector        information like corrections applied automatically or        performance settings. '
root['/entry/instrument/detector/data'].attrs['EX_doc'] = 'For a dimension-2 detector, the rank of the data array will be 3.        For a dimension-3 detector, the rank of the data array will be 4.        This allows for the introduction of the frame number as the        first index. '
root['/entry/instrument/detector/description'].attrs['EX_doc'] = 'name/manufacturer/model/etc. information. '
root['/entry/instrument/detector/time_per_channel'].attrs['EX_doc'] = 'For a time-of-flight detector this is the scaling        factor to convert from the numeric value reported to        the flight time for a given measurement. '
root['/entry/instrument/detector/NXdetector_module'].attrs['EX_doc'] = 'Many detectors consist of multiple smaller modules that are        operated in sync and store their data in a common dataset.        To allow consistent parsing of the experimental geometry,        this application definiton requires all detectors to        define a detector module, even if there is only one.        This group specifies the hyperslab of data in the data        array associated with the detector that contains the        data for this module. If the module is associated with        a full data array, rather than with a hyperslab within        a larger array, then a single module should be defined,        spanning the entire array. '
root['/entry/instrument/detector/NXdetector_module/data_origin'].attrs['EX_doc'] = 'A dimension-2 or dimension-3 field which gives the indices         of the origin of the hyperslab of data for this module in the         main area detector image in the parent NXdetector module.         The data_origin is 0-based.         The frame number dimension (nP) is omitted. Thus the         data_origin field for a dimension-2 dataset with indices (nP, i, j)         will be an array with indices (i, j), and for a dimension-3         dataset with indices (nP, i, j, k) will be an array with indices         (i, j, k).         The :ref:`order <Design-ArrayStorageOrder>` of indices (i, j         or i, j, k) is slow to fast. '
root['/entry/instrument/detector/NXdetector_module/data_size'].attrs['EX_doc'] = 'Two or three values for the size of the module in pixels in         each direction. Dimensionality and order of indices is the         same as for data_origin. '
root['/entry/instrument/detector/NXdetector_module/data_stride'].attrs['EX_doc'] = 'Two or three values for the stride of the module in pixels in         each direction. By default the stride is [1,1] or [1,1,1],         and this is the most likely case. This optional field is         included for completeness. '
root['/entry/instrument/detector/NXdetector_module/module_offset'].attrs['EX_doc'] = 'Offset of the module in regards to the origin of the detector in an         arbitrary direction. '
root['/entry/instrument/detector/NXdetector_module/fast_pixel_direction'].attrs['EX_doc'] = 'Values along the direction of :ref:`fastest varying <Design-ArrayStorageOrder>`         pixel direction. The direction itself is given through the vector         attribute. '
root['/entry/instrument/detector/NXdetector_module/slow_pixel_direction'].attrs['EX_doc'] = 'Values along the direction of :ref:`slowest varying <Design-ArrayStorageOrder>`         pixel direction. The direction itself is given through the vector         attribute. '
root['/entry/instrument/detector/distance'].attrs['EX_doc'] = 'Distance from the sample to the beam center.        Normally this value is for guidance only, the proper        geometry can be found following the depends_on axis chain,        But in appropriate cases where the dectector distance        to the sample is observable independent of the axis        chain, that may take precedence over the axis chain        calculation. '
root['/entry/instrument/detector/distance_derived'].attrs['EX_doc'] = 'Boolean to indicate if the distance is a derived, rather than        a primary observation. If distance_derived true or is not specified,        the distance is assumed to be derived from delector axis        specifications. '
root['/entry/instrument/detector/dead_time'].attrs['EX_doc'] = 'Detector dead time. '
root['/entry/instrument/detector/count_time'].attrs['EX_doc'] = 'Elapsed actual counting time. '
root['/entry/instrument/detector/beam_center_derived'].attrs['EX_doc'] = 'Boolean to indicate if the distance is a derived, rather than        a primary observation. If true or not provided, that value of        beam_center_derived is assumed to be true. '
root['/entry/instrument/detector/beam_center_x'].attrs['EX_doc'] = 'This is the x position where the direct beam would hit the        detector. This is a length and can be outside of the actual        detector. The length can be in physical units or pixels as        documented by the units attribute. Normally, this should        be derived from the axis chain, but the direct specification        may take precedence if it is not a derived quantity. '
root['/entry/instrument/detector/beam_center_y'].attrs['EX_doc'] = 'This is the y position where the direct beam would hit the        detector. This is a length and can be outside of the actual        detector. The length can be in physical units or pixels as        documented by the units attribute. Normally, this should        be derived from the axis chain, but the direct specification        may take precedence if it is not a derived quantity. '
root['/entry/instrument/detector/angular_calibration_applied'].attrs['EX_doc'] = 'True when the angular calibration has been applied in the        electronics, false otherwise. '
root['/entry/instrument/detector/angular_calibration'].attrs['EX_doc'] = 'Angular calibration data. '
root['/entry/instrument/detector/flatfield_applied'].attrs['EX_doc'] = 'True when the flat field correction has been applied in the        electronics, false otherwise. '
root['/entry/instrument/detector/flatfield'].attrs['EX_doc'] = 'Flat field correction data. If provided, it is recommended        that it be compressed. '
root['/entry/instrument/detector/flatfield_error'].attrs['EX_doc'] = '*** Deprecated form. Use plural form ***        Errors of the flat field correction data. If provided, it is recommended        that it be compressed. '
root['/entry/instrument/detector/flatfield_errors'].attrs['EX_doc'] = 'Errors of the flat field correction data. If provided, it is recommended        that it be compressed. '
root['/entry/instrument/detector/pixel_mask_applied'].attrs['EX_doc'] = 'True when the pixel mask correction has been applied in the        electronics, false otherwise. '
root['/entry/instrument/detector/pixel_mask'].attrs['EX_doc'] = 'The 32-bit pixel mask for the detector. Can be either one mask        for the whole dataset (i.e. an array with indices i, j) or        each frame can have its own mask (in which case it would be        an array with indices nP, i, j).        Contains a bit field for each pixel to signal dead,        blind, high or otherwise unwanted or undesirable pixels.        They have the following meaning:         * bit 0: gap (pixel with no sensor)         * bit 1: dead         * bit 2: under-responding         * bit 3: over-responding         * bit 4: noisy         * bit 5: -undefined-         * bit 6: pixel is part of a cluster of problematic pixels (bit set in addition to others)         * bit 7: -undefined-         * bit 8: user defined mask (e.g. around beamstop)         * bits 9-30: -undefined-         * bit 31: virtual pixel (corner pixel with interpolated value)        Normal data analysis software would not take pixels into account        when a bit in (mask & 0x0000FFFF) is set. Tag bit in the upper        two bytes would indicate special pixel properties that normally        would not be a sole reason to reject the intensity value (unless        lower bits are set.        If the full bit depths is not required, providing a        mask with fewer bits is permissible.        If needed, additional pixel masks can be specified by        including additional entries named pixel_mask_N, where        N is an integer. For example, a general bad pixel mask        could be specified in pixel_mask that indicates noisy        and dead pixels, and an additional pixel mask from        experiment-specific shadowing could be specified in        pixel_mask_2. The cumulative mask is the bitwise OR        of pixel_mask and any pixel_mask_N entries.        If provided, it is recommended that it be compressed. '
root['/entry/instrument/detector/countrate_correction_applied'].attrs['EX_doc'] = 'True when a count-rate correction has already been applied in        the data recorded here, false otherwise. '
root['/entry/instrument/detector/bit_depth_readout'].attrs['EX_doc'] = 'How many bits the electronics record per pixel. '
root['/entry/instrument/detector/detector_readout_time'].attrs['EX_doc'] = 'Time it takes to read the detector (typically milliseconds).        This is important to know for time resolved experiments. '
root['/entry/instrument/detector/frame_time'].attrs['EX_doc'] = 'This is time for each frame. This is exposure_time + readout        time. '
root['/entry/instrument/detector/gain_setting'].attrs['EX_doc'] = 'The gain setting of the detector. This influences background. '
root['/entry/instrument/detector/saturation_value'].attrs['EX_doc'] = 'The value at which the detector goes into saturation.        Data above this value is known to be invalid.        For example, given a saturation_value and an underload_value,        the valid pixels are those less than or equal to the        saturation_value and greater than or equal to the underload_value. '
root['/entry/instrument/detector/underload_value'].attrs['EX_doc'] = 'The lowest value at which pixels for this detector        would be reasonably be measured.        For example, given a saturation_value and an underload_value,        the valid pixels are those less than or equal to the        saturation_value and greater than or equal to the underload_value. '
root['/entry/instrument/detector/sensor_material'].attrs['EX_doc'] = 'At times, radiation is not directly sensed by the detector.        Rather, the detector might sense the output from some        converter like a scintillator.        This is the name of this converter material. '
root['/entry/instrument/detector/sensor_thickness'].attrs['EX_doc'] = 'At times, radiation is not directly sensed by the detector.        Rather, the detector might sense the output from some        converter like a scintillator. This is the thickness of this        converter material. '
root['/entry/instrument/detector/threshold_energy'].attrs['EX_doc'] = 'Single photon counter detectors can be adjusted for a certain        energy range in which they work optimally. This is the energy        setting for this. If the detector supports multiple thresholds,        this is an array. '
root['/entry/instrument/detector/type'].attrs['EX_doc'] = 'Description of type such as scintillator,        ccd, pixel, image        plate, CMOS, ... '
root['/entry/instrument/beam/incident_wavelength'].attrs['EX_doc'] = 'In the case of a monchromatic beam this is the scalar        wavelength.        Several other use cases are permitted, depending on the        presence or absence of other incident_wavelength_X        fields.        In the case of a polychromatic beam this is an array of        length **m** of wavelengths, with the relative weights        in ``incident_wavelength_weights``.        In the case of a monochromatic beam that varies shot-        to-shot, this is an array of wavelengths, one for each        recorded shot. Here, ``incident_wavelength_weights`` and        incident_wavelength_spread are not set.        In the case of a polychromatic beam that varies shot-to-        shot, this is an array of length **m** with the relative        weights in ``incident_wavelength_weights`` as a 2D array.        In the case of a polychromatic beam that varies shot-to-        shot and where the channels also vary, this is a 2D array        of dimensions **nP** by **m** (slow to fast) with the        relative weights in ``incident_wavelength_weights`` as a 2D        array.        Note, :ref:`variants <Design-Variants>` are a good way        to represent several of these use cases in a single dataset,        e.g. if a calibrated, single-value wavelength value is        available along with the original spectrum from which it        was calibrated. '
root['/entry/instrument/beam/incident_wavelength_weight'].attrs['EX_doc'] = 'In the case of a polychromatic beam this is an array of        length **m** of the relative weights of the corresponding        wavelengths in incident_wavelength.        In the case of a polychromatic beam that varies shot-to-        shot, this is a 2D array of dimensions **nP** by **m**        (slow to fast) of the relative weights of the        corresponding wavelengths in incident_wavelength. '
root['/entry/instrument/beam/incident_wavelength_weights'].attrs['EX_doc'] = 'In the case of a polychromatic beam this is an array of        length **m** of the relative weights of the corresponding        wavelengths in ``incident_wavelength``.        In the case of a polychromatic beam that varies shot-to-        shot, this is a 2D array of dimensions **np** by **m**        (slow to fast) of the relative weights of the        corresponding wavelengths in ``incident_wavelength``. '
root['/entry/instrument/beam/incident_wavelength_spread'].attrs['EX_doc'] = 'The wavelength spread FWHM for the corresponding        wavelength(s) in incident_wavelength.        In the case of shot-to-shot variation in the wavelength        spread, this is a 2D array of dimension **nP** by        **m** (slow to fast) of the spreads of the        corresponding wavelengths in incident_wavelength. '
root['/entry/instrument/beam/flux'].attrs['EX_doc'] = 'Flux density incident on beam plane area in photons        per second per unit area.        In the case of a beam that varies in flux shot-to-shot,        this is an array of values, one for each recorded shot. '
root['/entry/instrument/beam/total_flux'].attrs['EX_doc'] = 'Flux incident on beam plane in photons per second.        In the case of a beam that varies in total flux shot-to-shot,        this is an array of values, one for each recorded shot. '
root['/entry/instrument/beam/incident_beam_size'].attrs['EX_doc'] = 'Two-element array of FWHM (if Gaussian or Airy function) or        diameters (if top hat) or widths (if rectangular) of the beam        in the order x, y '
root['/entry/instrument/beam/profile'].attrs['EX_doc'] = 'The beam profile, Gaussian, Airy function, top-hat or        rectangular. The profile is given in the plane of        incidence of the beam on the sample. '
root['/entry/source'].attrs['EX_doc'] = 'The neutron or x-ray storage ring/facility. Note, the NXsource base class      has many more fields available, but at present we only require the name. '
root['/entry/source/name'].attrs['EX_doc'] = 'Name of source. Consistency with the naming in       https://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_diffrn_source.pdbx_synchrotron_site.html       controlled vocabulary is highly recommended. '
 

# Create the ATTRIBUTES 
root['/entry'].attrs['version'] = 'SAMPLE-CHAR-DATA'
root['/entry/instrument/name'].attrs['short_name'] = 'SAMPLE-CHAR-DATA'
root['/entry/instrument/detector/NXdetector_module/module_offset'].attrs['transformation_type'] = 'SAMPLE-CHAR-DATA'
root['/entry/instrument/detector/NXdetector_module/module_offset'].attrs['depends_on'] = 'SAMPLE-CHAR-DATA'
root['/entry/instrument/detector/NXdetector_module/fast_pixel_direction'].attrs['transformation_type'] = 'SAMPLE-CHAR-DATA'
root['/entry/instrument/detector/NXdetector_module/fast_pixel_direction'].attrs['depends_on'] = 'SAMPLE-CHAR-DATA'
root['/entry/instrument/detector/NXdetector_module/slow_pixel_direction'].attrs['transformation_type'] = 'SAMPLE-CHAR-DATA'
root['/entry/instrument/detector/NXdetector_module/slow_pixel_direction'].attrs['depends_on'] = 'SAMPLE-CHAR-DATA'
root['/entry/source/name'].attrs['short_name'] = 'SAMPLE-CHAR-DATA'
root.attrs['default'] = 'entry'
root['/entry/data'].set_default()
root['/entry/data'].attrs['signal'] = 'data'
root['/entry/data/data'].attrs['signal'] = '1'

# Save the file
root.save('NXmx.nxs', 'w')


